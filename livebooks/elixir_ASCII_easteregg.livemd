# Elixir goes ASCII Art Â¯\_(ãƒ„)_/Â¯: The easter egg

## It's (nerdy) easter time!

The aim is to create an egg-shaped pattern in your terminal that is made up of characters from the given string Elixir.

The following code achieves that by using a combination of mathematical equations and string manipulation techniques.

You'll find a step-by-step breakdown after the code. Let's go!

```elixir
defmodule EasterEgg do
  @egg String.graphemes("Elixir ")

  def character_at(x, y) do
    index = rem(x - y, length(@egg))
    char = Enum.at(@egg, index)

    case math_power(x, y) do
      true -> char
      false -> " "
    end
  end

  def math_power(x, y) do
    case y > 0 do
      true -> :math.pow(x / 2.5, 2) + :math.pow(y / 2, 2) <= 100
      false -> :math.pow(x / 2.5, 2) + :math.pow(y / 1, 2) <= 100
    end
  end

  def patch_together() do
    -13..23
    |> Enum.map(fn y ->
      -30..30
      |> Enum.map(fn x -> EasterEgg.character_at(x, y) end)
      |> Enum.join("")
    end)
    |> Enum.reverse()
    |> Enum.join("\n")
  end
end

IO.puts(EasterEgg.patch_together())
```

## Let's break it down

The definition of the module `EasterEgg` contains the module attribute `egg`, and the functions `character_at`,  `math_power`, and `patch_together`.

The code is split into 5 parts:

1. The module attribute `egg` stores the string "Elixir ", chopped into its chars. (â€¦ of course, you can change the value to whatever you want, however, paying homage to our beloved Elixir lang seemed kinda fitting to start with ðŸ™ƒ)

2. The function `character_at` calculates the index of the character in the @egg string using the modulo operator (which returns the remainder of the division of its first argument by its second argument) and the length of the string.

3. The function `math_power` takes two arguments, x and y, and returns a boolean, indicating whether the point (x, y) is inside the egg shape or not.

* It's based on the mathematical formula for an ellipse xÂ²/bÂ² + yÂ²/aÂ² = 1

* We stitch together two ellipses to form an egg shape, depending on whether y > 0. For values meeting that condition, the shape gets broader, and for values not meeting that condition, the shape gets narrower.

* To play around with this math part, visit: <https://www.wolframalpha.com/input?i=%28y%2F2.5%29Â²+%2B+%28x%2F2%29Â²+%3D+1>

1. The function `patch_together` is the main function that creates the egg shape. It does so by:

* maps over a range of y values, and for each y value, again maps over a range of x values in order to create a row of characters for that specific y value.

* joins the characters in each of those rows to form a string.

* reverses the order of all the rows to make the egg point upwards.

* joins all the rows with a newline character to form the complete egg shape.

1. The last section of the code calls the `patch_together` function and prints the result to the terminal.

<!-- livebook:{"break_markdown":true} -->

![](images/ASCII_egg_elixir.png)
